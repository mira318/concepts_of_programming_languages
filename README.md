# concepts_of_programming_languages
Studying repository

Инструкция:

В данный момент в репозитории отдельно существуют 2 проекта: byte_encoder и VM

byte_encoder - кодировшик под Ассемблер. Согласование с VM стало лучше, но многие команды до сих пор не реализованы и нуждаются в уточнениях.

VM - виртуальная машина. Сейчас она умеет мало, но это должно быть хорошим началом.
Правила: 
- VM принимает на вход строку с относительным или полным адресом файла с программой в bytecode.
- Любая программа начинается с команды 0C 00 00 00 - она обозначает сдвиг IP. Далее идёт указание, что следующий аргумент - адрес: 02 00 00 00, а потом уже сам этот адрес, записанный в таком же виде (4 двузначных шестандцатеричных числа = 4 байта).
- Любая команда - это последовательность из 20 байт: 4 для номера команды, 4 для типа первого аргумента, 4 для первого аргумента, 4 для типа второго аргумента и 4 для второго аргумента. Если кого-то аргумента нет, соответствующие байты заполняются нулями.std::cout << "command_num = " << command_num << std::endl;
- Любая программа должна заканчиваться командой остановки 04 00 00 00.

Аргументы команд:
- Любой аргумент задаётся двумя числами: сначала тип аргумента, а потом сам аргумент.
- Типы: 
-       1 - для регистров, далее следует номер регистра. Пока регистров 8: с 0 по 7. В регистре 7 хранится IP, пользователю он не доступен. Остальными регистрами можно свободно пользоваться. Таким образом любой номер с 0 по 6 является валидным обозначением регистра.
-       2 - для адресов в памяти, далее следует адрес. Адреса вычисляются от начала программы, начиная с 0, и находятся внутри файла с программой. Адрес - положительное число из стандартного диапозона int (4 байта со знаком).
-       3 - для чисел, далее следует само число. Числа целые, из диапозона стандартного int (4 байта со знаком)
-       4 - для строк.

Реализована команда 0D 00 00 00 - вывод строки в консоль. Она принимает на вход адрес, т. е. сначала обозначение 02 00 00 00, а потом адрес ячейки в памяти, где начинается строка. Строка должна заканчиваться символом 00. Пока получается работать только с латинскими строками.
- В файле byte_input.bin лежит программа для вывода в консоль строки "Hello world!".
- В файле harder_input.bin лежит программа посложнее, показывающая, что данные и команды могут быть перемешаны. 

Реализована команда 01 00 00 00 - "передвинуть" (переместить) число. 
- У этой команды всегда 2 аргумента.
- Первый аргумен команды: источник. Это может быть число, адрес, или регистр.
- Второй аргумен: место назначения. Это адрес или регистр.
- Разрешены любые операции в пределах указанных аргументов. Передвинуть из адреса в адрес тоже можно, но будет показано предупреждение о том, что это долгая операция.

Релизована команда 0B 00 00 00 - вывести число в консоль.
- У этой команды один аргумент.
- Аргумент может быть регистром, адресом или числом.
- В байт-коде подаётся шестандцатеричное число. На консоль выводится десятичное.

- В файле move_check.bin лежит простой пример на перемещение и вывод - если всё правильно, программа должна вывести в консоль число 7.
- В файле move_out_check.bin лежит более сложный пример, который показывает практически все возможности последних двух команд.
Вывод в консоль:
  37448
  112
  112
  WARNING: it takes too much time to move from memory to memory, but I will do it.
  37448
  5

Реализована команда 04 00 00 00 - прекратить выполнение.
- У команды нет аргументов. Рекомендуется заполнить оставшиеся 4 поля нулями, но можно попытаться сохранить там что-то более полезное или не сохранить ничего, чтобы уменьшить размер файла.

Реализована команда 0A 00 00 00 - считать число с консоли.
- У команды один аргумент: регистр или адрес, в который нужно положить считанное число.
- Принимаются целые числа в стандартном диапозоне int (4 байта).
- Программа не выводит никаких приглашений и предупреждений. Она просто ожидает число. Все приглашения должны быть реализованы отдельно.

Реализованы команды 02 00 00 00 - перейти к инструкции, если перед нами 0 и 03 00 00 00 - перейти к инструкции, если перед нами НЕ 0.
- Обе команды принимают 2 аргумента: 
-     число, регистр или адрес, которые надо проверить на 0
-     адрес, по которому надо перейти, если условие выполнено.
- Если условие не выполнено, VM перейдёт в следующей команде в файле, для этого ничего делать не нужно.
- Для обязательных переходов можно использовать команду 0C 00 00 00 или сравнивать в JZ с числом 0.

- В файле jz_input_check.bin реализована программа на проверку считывания и условных переходов. Если ввести программе число 0, она завершится. Если 2 раза ввести ненулевое число, то она завершиться и выведет строку "You win!" в консоль. 

Реализована команда 05 00 00 00 - сложить 2 целых числа в стандартном диапозоне int (4 байта).
- У команды 2 аргумента. Первый аргумент может быть регистром или адресом. Второй аргумент может быть регистром, адресом или числом.
- Разрешены любые сложения в пределах указанных аргументов. Складывать 2 числа в памяти (по адресам) тоже можно, но VM выведет предупреждение о том, что это слишком долгая операция.
- При сложении может возникнуть переполнение. Тогда в качестве ответа получим тот же результат что и при переполнении аналогичных int. Это ведёт к UB и такое лучше не допускать.
- Результат сложения будет сохранён в ПЕРВОМ аргументе - регистре или адресе в памяти. Во втором аргументе останется второе слагаемое.

Реализована команда 06 00 00 00 - сложить 2 целых числа в стандартном диапозоне int (4 байта).
- У команды 2 аргумента. Первый аргумент может быть регистром или адресом. Второй аргумент может быть регистром, адресом или числом.
- Разрешены любые сложения в пределах указанных аргументов. Вычитать 2 числа в памяти (по адресам) тоже можно, но VM выведет предупреждение о том, что это слишком долгая операция.
- При вычитании может возникнуть переполнение. Тогда в качестве ответа получим тот же результат что и при переполнении аналогичных int. Это ведёт к UB и такое лучше не допускать.
- Результат вычитания будет сохранён в ПЕРВОМ аргументе - регистре или числе. Во втором аргументе останется вычитаемое.

- В файле sub_add_check.bin реализована программа для проверки операций сложения и вычитания.
В программу нужно через пробел ввести 2 числа, обозначим их a и b. Далее программа выведет 
a + b
b - 16
a + b + 5
предупреждение, что вычитать в памяти слишком долго
5

Детали для сборки: проекты собираются с помощью cmake файлов CMakeLists.txt, рекомендуется проводить сбрку в отдельных директориях.

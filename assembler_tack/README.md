# concepts_of_programming_languages
Studying repository

Инструкция:

В данный момент в репозитории отдельно существуют 2 проекта: byte_encoder и VM

byte_encoder - кодировщик из "Ассемблера" в байт-код. Полностью согласован с VM. Описание в отдельном файле assembly_instruction.txt
VM - виртуальная машина. 
Правила: 
- VM принимает на вход строку с относительным или полным адресом файла с программой в bytecode.
- Любая программа начинается с команды 0C 00 00 00 - она обозначает сдвиг IP. Далее идёт указание, что следующий аргумент - адрес: 02 00 00 00, а потом уже сам этот адрес, записанный в таком же виде (4 двузначных шестандцатеричных числа = 4 байта).
- Любая команда - это последовательность из 20 байт: 4 для номера команды, 4 для типа первого аргумента, 4 для первого аргумента, 4 для типа второго аргумента и 4 для второго аргумента. Если кого-то аргумента нет, соответствующие байты заполняются нулями.std::cout << "command_num = " << command_num << std::endl;
- Любая программа должна заканчиваться командой остановки 04 00 00 00.

Аргументы команд:
- Любой аргумент задаётся двумя числами: сначала тип аргумента, а потом сам аргумент.
- Типы: 
-       1 - для регистров, далее следует номер регистра. Пока регистров 8: с 0 по 7. В регистре 7 хранится IP, пользователю он не доступен. Остальными регистрами можно свободно пользоваться. Таким образом любой номер с 0 по 6 является валидным обозначением регистра.
-       2 - для адресов в памяти, далее следует адрес. Адреса вычисляются от начала программы, начиная с 0, и находятся внутри файла с программой. Адрес - положительное число из стандартного диапозона int (4 байта со знаком).
-       3 - для чисел, далее следует само число. Числа целые, из диапозона стандартного int (4 байта со знаком)
-       4 - для строк.

Команды те же, что в Ассемблере, но вместо названий цифровые обозначения в шестнадцатеричной системе счисления.
01 00 00 00 - MOVE
02 00 00 00 - JZ
03 00 00 00 - JNZ
04 00 00 00 - STOP
05 00 00 00 - ADD
06 00 00 00 - SUB
0A 00 00 00 - INP
0B 00 00 00 - OUT
0C 00 00 00 - IP
0D 00 00 00 - OUTS
0E 00 00 00 - CALL
0F 00 00 00 - RET

В байт-коде имена функций не записываются, а подменяются соответствующими адресами в памяти. Поэтому команда CALL работает с адресом памяти, с которого начинается вызываемая функция.

- В файле byte_input.bin лежит программа для вывода в консоль строки "Hello world!".
- В файле harder_input.bin лежит программа посложнее, показывающая, что данные и команды могут быть перемешаны. 

- В файле move_check.bin лежит простой пример на перемещение и вывод - если всё правильно, программа должна вывести в консоль число 7.
- В файле move_out_check.bin лежит более сложный пример, который показывает практически все возможности последних двух команд.
Вывод в консоль:
  37448
  112
  112
  WARNING: it takes too much time to move from memory to memory, but I will do it.
  37448
  5

- В файле jz_input_check.bin реализована программа на проверку считывания и условных переходов. Если ввести программе число 0, она завершится. Если 2 раза ввести ненулевое число, то она завершиться и выведет строку "You win!" в консоль. 

- В файле sub_add_check.bin реализована программа для проверки операций сложения и вычитания.
В программу нужно через пробел ввести 2 числа, обозначим их a и b. Далее программа выведет 
a + b
b - 16
a + b + 5
предупреждение, что вычитать в памяти слишком долго
5

- fibonacci.txt - программа на этом языке, которая вычисляет число Фибоначчи по его номеру. Ограничения взяты так, чтобы ответ помещался в стандартный int (4 байта).
- byte_fibonacci.bin - результат дизассемблирования программы fibonacci.txt, может быть запущен на соседней VM, лежит чуть выше, чтобы было проще запускать.

- В файле func_input.txt лежит программа на Ассемблере для проверки рекурсии.
- В файле func.bin - лежит байт-код программы из func_input.txt полученный с помощью byte_encoder. Он может быть запущени на VM как отдельная программа.

Детали для сборки: проекты собираются с помощью cmake файлов CMakeLists.txt, рекомендуется проводить сбрку в отдельных директориях.

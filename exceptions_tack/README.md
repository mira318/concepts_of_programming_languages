Перед Вами моё решение задачи на исключения.

Все макросы, а так же все классы и функции, которые нужны для работы макросов, реализованы в exceptions.h Этот файл можно воспринемать как библиотеку и даже подключать в сторонние проекты.

Про макросы:

INIT - нужен для некоторое иницаилизации, должен быть написан в начале любой программы, использующей библиотеку.

TRY - обозначает начало небезопастного участка кода. Все исключения должны выбрасываться только внутри TRY

THROW("string") - выбрасывает исключение string. Выбрасывать в качестве исключений можно любые строки. Часть строк относится к типизированным исключениям -- они задаются так же целыми числами и легче храняться/передаются. Типизированы RUNTIME_EXCEPTION, NO_SUCH_ELEMENT_EXCEPTION, INDEX_OUT_OF_BOUNDS_EXCEPTION, ARITHMETIC_EXCEPTION, CLASS_CAST_EXCEPTION, NULL_POINTER_EXCEPTION, ILLEGAL_ARGUMENT_EXCEPTION, EOF_EXCEPTION, FILE_NOT_FOUNDED_EXCEPTION, NO_SUCH_FIELD_EXCEPTION, ILLEGAL_ACCESS_EXCEPTION, CLASS_NOT_FOUNDED_EXCEPTION, NO_SUCH_METHOD_EXCEPTION. Все остальные выброшенные строки будут отнесены к некоторому отдельному типу. 

CATCH("string") - отлавливает исключение string и только его. В том числе: если было выброшено некоторое нетипизированное исключение, то поймать его може только CATCH с ровно такой же строкой.

END_CATCH завершает блок кода, который выполняется в случае исключения. Обязателен при написании CATCH.

RETHROW - выбросить ровно то исключение, которое обрабатывается в CATCH заново. RETHROW необходимо писать внутри CATCH.

REGISTER(type, obj) - зарегистрировать объект obj типа type. Регистрация гарантирует, что, в случае выброса исключения, перед переходм к его обработке будет вызван деструктор объекта. Т. е. происходит размотка стека.

Про тесты:

Как уже было сказано, exceptions.h - библиотека. Файлы test_container_throw.cpp и  test_macros.cpp -- примеры её использования.

test_container_throw.cpp -- демонстрирует случай повторного выброса исключения в деструкторе при размотке стека. Программа немедленно остановится и выдаст соответствующую ошибку. Последние разрушение происходит уже после завершение программы по exit(1) -- таков стандарт.

test_macros -- демонстрирует примеры правильного использования библиотеки.

Функции test_simple_inner() и test_hard_inner() -- показывают, что исключение ловится только своим CATCH, что оно может быть перевыброшено несколько раз и снова поймано, что зарегистрированные объекты действительно удаляются при вызове THROW и это происходит в обратном порядке.

Функция test_in_function() показывает, что исключение может быть выброшено сколь угодно глубоко внутри функции, что оно может "пролететь" несколько функций до своего CATCH и что все зарегистрированные объекты так же будут правильно разрушены.

Функция test_my_own_exception() показывает, что в качестве исключения можно выбросить любую строку, но поймать его можно будет только такой же строкой в CATCH.

Я попыталась сделать подробный вывод, чтобы было видно что и где создаётся/разрушается и ловится. В итоге вышло довольно грамоздко, но надеюсь читаемо. Ещё в конце программа выводит пару "лишних" удалений. Это те самые переменные, которые должны были остаться на стеке навсегда. Последняя скобка закрывается и уже сам С++ их разрушает.

Про сборку:

Файл для сборки под cmake - CMakeLists.txt Поскольку exceptions.h воспринемается как библиотека, то этот файл линкуется. Собираем же исполняемые файлы для test_macros.cpp и test_container_throw.cpp



